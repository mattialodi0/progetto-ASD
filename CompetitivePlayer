package mnkgame;

import java.util.Random;
import java.util.ArrayList;
import java.util.HashSet;

//usa un array dinamico per BC


public class CompetitivePlayer1  implements MNKPlayer {
	private Random rand;
    private int M;
    private int N;
    private int K;
	private MNKBoard B;
	private MNKGameState myWin;
	private MNKGameState yourWin;
	private int TIMEOUT;
    private boolean first;

	public CompetitivePlayer1() {
	}

	public void initPlayer(int M, int N, int K, boolean first, int timeout_in_secs) {

        rand    = new Random(System.currentTimeMillis()); 
		this.M  = M;
        this.N  = N;
        this.K  = K;
		B       = new MNKBoard(M,N,K);
		myWin   = first ? MNKGameState.WINP1 : MNKGameState.WINP2; 
		yourWin = first ? MNKGameState.WINP2 : MNKGameState.WINP1;
		TIMEOUT = timeout_in_secs;
        this.first = first;
	}

	public MNKCell selectCell(MNKCell[] FC, MNKCell[] MC) {

		if(MC.length > 0) {
			MNKCell c = MC[MC.length-1]; 
			B.markCell(c.i,c.j);         
		}
        else if(MC.length == 0) {
            //se è la prima mossa mette il simbolo al centro
            int m = M/2;
            int n = N/2;
            MNKCell s = new MNKCell(m, n);
			B.markCell(s.i,s.j);
            return s;
        }

        if(FC.length == 1) {
            return FC[0];
		}

        //iterative deepening
        final int max_depth = 5;
        double min_a = -1.0;
        double max_b = 1.0;
        int index = 0;
        ArrayList<MNKCell> BC = bestCells(B, (B.currentPlayer() == 0) ? MNKCellState.P1 : MNKCellState.P2);

        for(int i=0; i < max_depth; i++) {
            double[] results = new double[BC.size()];
            for(int j=0; j < BC.size(); j++) {          //il numero di iterazioni può essere ridotto per migliorare le prestazioni; <c> (BC.size()<5 ? BC.size() : 5) <c>
                B.markCell(BC.get(j).i, BC.get(j).j);
                results[j] = AlphaBeta(B, min_a, max_b, i);     //migliorabile in caso di vittoria 
                B.unmarkCell();

                /*if(B.currentPlayer() == 0 && results[j] == 1 || B.currentPlayer() == 1 && results[j] == -1) {         //caso di vittoria immediata, 
                //if(results[j] == -1) {                                                                                //migliora solo il tempo 
                    B.markCell(BC.get(j).i, BC.get(j).j);                                                               
                    return BC.get(j);
                }*/
            }
            if(B.currentPlayer() == 0) {            //*********************************************************
                double max = -1000;
                for(int j=0; j < BC.size(); j++) {
                    if(results[j] > max) {
                       max = results[j];
                      index = j;
                    }
                }
            }
            else {
                double min = 1000;
                for(int j=0; j < BC.size(); j++) {
                    if(results[j] < min) {
                       min = results[j];
                      index = j;
                    }
                }
            }
        }

        B.markCell(BC.get(index).i, BC.get(index).j);
        return BC.get(index);
	}

	public String playerName() {
		return "C0mp3t1t1v3I";
	}


    

    private double AlphaBeta(MNKBoard B, double a, double b, int depth) {
        double eval = 0.0;

        if(MNKGameState.WINP1 == B.gameState() ) {  
            eval = 1;                                    //??????????? dovrebbe essere il contrario
        }
        else if(MNKGameState.WINP2 == B.gameState()) {
            eval = -1;
        }
        else if(MNKGameState.DRAW == B.gameState()) {
            eval = 0;
        }
        else if(depth == 0 || B.getFreeCells().length == 0) {
            eval = evaluation(B);
        }
        else if(B.currentPlayer() == 0) {
            eval = -10;
            //crea l'array di mosse migliori
            ArrayList<MNKCell> BC = bestCells(B, (B.currentPlayer() == 0) ? MNKCellState.P1 : MNKCellState.P2);
            //va per ricorsione
            for(MNKCell c : BC) { 
                B.markCell(c.i, c.j);
                eval = Math.max(eval, AlphaBeta(B, a, b, depth-1));
                a = Math.max(a, eval);
                B.unmarkCell();
                if(b <= a) break;
            }
        }
        else if(B.currentPlayer() == 1) {
            eval = 10;
            //crea l'array di mosse migliori
            ArrayList<MNKCell> BC = bestCells(B, (B.currentPlayer() == 0) ? MNKCellState.P1 : MNKCellState.P2);     //dovrebbe essere migliore ma non lo è
            //va per ricorsione
            for(MNKCell c : BC) { 
                B.markCell(c.i, c.j);
                eval = Math.min(eval, AlphaBeta(B, a, b, depth-1));
                b = Math.min(b, eval);
                B.unmarkCell();
                if(b <= a) break;
            }
        }

        return eval;
    }

    private double evaluation(MNKBoard B) {     //verifica solo la sequenza più lunga non se è stata già bloccata o no (futura implementazione)
        double max_p1 = 0;
        double max_p2 = 0;

        max_p1 = evaluate(B.B, MNKCellState.P1);
        max_p2 = evaluate(B.B, MNKCellState.P2);

        //if(max_p1 > max_p2) { System.out.println("p1 is winning " + max_p1 + " a " + max_p2); }
        //else if(max_p1 < max_p2) { System.out.println("p2 is winning " + max_p2 + " a " + max_p1); }
        //else if(max_p1 == max_p2) { System.out.println("draw"); }

        return (Math.atan(max_p2) - Math.atan(max_p1)) / (Math.PI / 2);  //funzione arcotangente
    }
    
    private double evaluate(MNKCellState[][] B, MNKCellState state) {
        int u_max = 0;
        int u = 0;

        //controllo delle colonne
        for(int k=0; k < N; k++) {
            for(int h=0; h < M; h++) {
                if(B[h][k] == state) {
                    u++;
                    u_max = Math.max(u, u_max);
                }
                else {
                    u = 0;
                }
            }
            u = 0;
        }

        //controllo delle righe
        for(int k=0; k < M; k++) {
            for(int h=0; h < N; h++) {
                if(B[k][h] == state) {
                    u++;
                    u_max = Math.max(u, u_max);
                    }
                else {
                    u = 0;
                }
            }
            u = 0;
        }
            
        //CONTROLLO DIAGONALE 
        for (int j = 0; j<N; j++) { // MATRICE TRIANGOLARE SUPERIORE
        	int l = 0;
        	while (l<M && j+l<N) {
        		if (l==0) {
        			u = 0;
        		}
        		if (B[l][j+l] == state) {
        			u++;
        			u_max = Math.max(u, u_max);
        		}
        		else {
        			u=0;
        		}
        		l++;
        	}
        }
        for (int i = 1; i<M; i++) { // MATRICE TRIANGOLARE INFERIORE
        	int l=0;
        	while (l<N && i+l<M) {
        		if (l==0) {
        			u=0;
        		}
        		if (B[i+l][l] == state) {
        			u++;
        			u_max = Math.max(u, u_max);
        		}
        		else {
        			u=0;
        		}
        		l++;
        	}
        }

     	// CONTROLLO ANTI-DIAGONALE
        for (int j = N; j>0; j--) { // MATRICE TRIANGOLARE SUPERIORE (ANTI)
        	int l = 0;
        	while (l<M && j-l>0) {
        		if (l==0) {
        			u=0;
        		}
        		if (B[l][j-l-1] == state) {
        			u++;
        			u_max = Math.max(u, u_max);
        		}
        		else {
        			u=0;
        		}
        		l++;
        	}
        }
        for (int i = 1; i<M; i++) { // MATRICE TRIANGOLARE INFERIORE (ANTI)
        	int l = 0;
        	while (l+i<M && N-l>0) {
        		if (l==0) {
        			u = 0;
        		}
        		if (B[i+l][N-l-1] == state) {
        			u++;
        			u_max = Math.max(u, u_max);
        		}
        		else {
        			u=0;
        		}
        		l++;
        	}
        }
        

        return (double)u_max;
    }

    private double evaluate1(MNKCellState[][] B, MNKCellState state) {
        double u_max = 0.0;
        double u = 0.0;
        double m1=0.75;
        double m2=0.75;
        
        //controllo delle colonne
        for(int k=0; k < N; k++) {
            for(int h=0; h < M; h++) {
            	if (h==0) { //sto iniziando a contare o non ho ancora cominciato
            		m1=0.75;
            	}
            	else {
            		if(u==0 && B[h-1][k] == MNKCellState.FREE) {
            			m1=1;
            		}
            		else if(u==0){
            			m1=0.75;
            		}
            	}
            	if (h==M-1) { //sto finendo di contare o non ho ancora finito
            		m2=0.75;
            	}
            	else {
            		if(u!=0 && B[h+1][k] == MNKCellState.FREE) {
                		m2=1;
            		}
            		else if(u!=0) {
            			m2=0.75;
            		}
            	}
                if(B[h][k] == state) {
                    u++;
                    u_max = Math.max(u*m1*m2, u_max);
                }
                else {
                    u = 0.0;
                }
            }
            u = 0.0;
        }

        //controllo delle righe
        for(int k=0; k < M; k++) {
            for(int h=0; h < N; h++) {
            	
            	if (h==0) { //sto iniziando a contare o non ho ancora cominciato
            		m1=0.75;
            	}
            	else {
            		if(u==0 && B[k][h-1] == MNKCellState.FREE) {
            			m1=1;
            		}
            		else if(u==0) {
            			m1=0.75;
            		}
            	}
            	if (h==N-1) { //sto finendo di contare o non ho ancora finito
            		m2=0.75;
            	}
            	else {
            		if(u!=0 && B[k][h+1] == MNKCellState.FREE) {
                		m2=1;
            		}
            		else if(u!=0){
            			m2=0.75;
            		}
            	}
            	
                if(B[k][h] == state) {
                    u++;
                    u_max = Math.max(u*m1*m2, u_max);
                    }
                else {
                    u = 0;
                }
            }
            u = 0;
        }
            
        //CONTROLLO DIAGONALE 
        for (int j = 0; j<N; j++) { // MATRICE TRIANGOLARE SUPERIORE
        	int l = 0;
        	while (l<M && j+l<N) {
        		if (l==0) { //sto iniziando a contare o non ho ancora cominciato
        			u = 0;
        			m1=0.75;
        		}
        		else {
        			if(u==0 && B[l-1][j+l-1] == MNKCellState.FREE) {
                		m1=1;
            		}
        			else if(u==0) {
        				m1=0.75;
        			}
        		}
        		if (l==M-1|| j+l==N-1) { //sto finendo di contare o non ho ancora finito
        			m2=0.75;
        		}
        		else {
        			if(u!=0 && B[l+1][j+l+1] == MNKCellState.FREE) { 
        				m2=1;
        			}
        			else if(u!=0 ){
        				m2=0.75;
        			}
        		}
        		if (B[l][j+l] == state) {
        			u++;
        			u_max = Math.max(u*m1*m2, u_max);
        		}
        		else {
        			u=0;
        		}
        		l++;
        	}
        }
        for (int i = 1; i<M; i++) { // MATRICE TRIANGOLARE INFERIORE
        	int l=0;
        	while (l<N && i+l<M) { //sto iniziando a contare o non ho ancora cominciato
        		if (l==0) {
        			u=0;
        			m1=0.75;
        		}
        		else {
        			if(u==0 && B[i+l-1][l-1] == MNKCellState.FREE) {
                		m1=1;
            		}
        			else if(u==0) {
        				m1=0.75;
        			}
        			
        		}
        		if (i+l==M-1||l==N-1) { //sto finendo di contare o non ho ancora finito
        			m2=0.75;
        		}
        		else {
        			if(u!=0 && B[i+l+1][l+1] == MNKCellState.FREE) {
        				m2=1;
        			}
        			else if(u!=0){
        				m2=0.75;
        			}
        		}
        		if (B[i+l][l] == state) {
        			u++;
        			u_max = Math.max(u*m1*m2, u_max);
        		}
        		else {
        			u=0;
        		}
        		l++;
        	}
        }
        
        // CONTROLLO ANTI-DIAGONALE
        for (int j = N; j>0; j--) { // MATRICE TRIANGOLARE SUPERIORE (ANTI)
        	int l = 0;
        	while (l<M && j-l>0) {
        		if (l==0) { //sto iniziando a contare o non ho ancora cominciato
        			u=0;
        			m1=0.75;
        		}
        		else {
        			if(u==0 && B[l-1][j-l] == MNKCellState.FREE) {
        				m1=1;
        			}
        			else if(u==0) {
        				m1=0.75;
        			}
        		}
        		if (l==M-1 || j-l==1) { //sto finendo di contare o non ho ancora finito
        			m2=0.75;
        		}
        		else {
        			if(u!=0 && B[l+1][j-l] == MNKCellState.FREE) {
        				m2=1;
        			}
        			else if (u!=0) {
        				m2=0.75;
        			}
        		}
        		
        		
        		if (B[l][j-l-1] == state) {
        			u++;
        			u_max = Math.max(u*m1*m2, u_max);
        		}
        		else {
        			u=0;
        		}
        		l++;
        	}
        }
        for (int i = 1; i<M; i++) { // MATRICE TRIANGOLARE INFERIORE (ANTI)
        	int l = 0;
        	while (l+i<M && N-l>0) {
        		if (l==0) { //sto iniziando a contare o non ho ancora cominciato
        			u = 0;
        			m1=0.75;
        		}
        		else {
        			if(u==0 && B[i+l-1][N-l]== MNKCellState.FREE) {
        				m1=1;
        			}
        			else if(u==0) {
        				m1=0.75;
        			}
        		}
        		if (l+i==M-1 || N-l==1) { //sto finendo di contare o non ho ancora finito
        			m2=0.75;
        		}
        		else {
        			if(u!=0 && B[i+l+1][N-l] == MNKCellState.FREE) {
        				m2=1;
        			}
        			else if (u!=0) {
        				m2=0.75;
        			}
        		}
        		
        		if (B[i+l][N-l-1] == state) {
        			u++;
        			u_max = Math.max(u*m1*m2, u_max);
        		}
        		else {
        			u=0;
        		}
        		l++;
        	}
        }
        

        return u_max;
    }


    private ArrayList<MNKCell> bestCells(MNKBoard B, MNKCellState state) {

        ArrayList<MNKCell> BC = findFreeCells(B, state);

        //nel caso in cui non sia stata trovata nessuna cella vuota popola casualmente BC, inutile con findFreeCells1
        if(BC.size() == 0) {
            BC.add(B.getFreeCells()[rand.nextInt(B.getFreeCells().length)]);
            BC.add(B.getFreeCells()[rand.nextInt(B.getFreeCells().length)]);
            BC.add(B.getFreeCells()[rand.nextInt(B.getFreeCells().length)]);
        }

        
        //ordina le altre mosse in base a quante caselle occupate dal giocatore ci sono vicine (controllo veloce ma efficace nelle matrici piccole)
        int max1 = 0;
        int max2 = 0;
        for(int i=0; i < BC.size(); i++) {
            int m = hasCloseCells(B, BC.get(i), state);
            if(m > max1) {
                max1 = m;
                MNKCell c = BC.get(i);
                BC.set(i, BC.get(0));
                BC.set(0, c);
            }
            else if(m > max2) {
                max2 = m;
                MNKCell c = BC.get(i);
                BC.set(i, BC.get(1));
                BC.set(0, c);
            }
        }
        

        //cerca una mossa per vincere
        for(int i=0; i < BC.size(); i++) {   //se la trova le da la massima priorità
            if(B.markCell(BC.get(i).i, BC.get(i).j) == (B.currentPlayer() == 0 ? myWin : yourWin)) {  //**************
                MNKCell c = BC.get(i);
                BC.set(i, BC.get(0));
                BC.set(0, c);
            }
            B.unmarkCell();
        }

        while(BC.size() > 5) {      //riduce la dimensione di BC a 5
            BC.remove(BC.size()-1);
        }

        return BC;
    }

    //ritorna per ogni cella il numero di celle vicine con il simbolo del giocatore corrente
    private int hasCloseCells(MNKBoard B, MNKCell c, MNKCellState state) {
        int cells = 0;

        if(c.i+1 < M && c.j+1 < N && B.B[c.i+1][c.j+1] == state) {
            cells += 1;
        }
        if(c.i+1 < M && B.B[c.i+1][c.j] == state) {
            cells += 1;
        }
        if(c.i+1 < M && c.j-1 > 0 && B.B[c.i+1][c.j-1] == state) {
            cells += 1;
        }
        if(c.j-1 > 0 && B.B[c.i][c.j-1] == state) {
            cells += 1;
        }
        if(c.i-1 > 0 && c.j-1 > 0 && B.B[c.i-1][c.j-1] == state) {
            cells += 1;
        }
        if(c.i-1 > 0 && B.B[c.i-1][c.j] == state) {
            cells += 1;
        }
        if(c.i-1 > 0 && c.j+1 < M && B.B[c.i-1][c.j+1] == state) {
            cells += 1;
        }
        if(c.j+1 < M && B.B[c.i][c.j+1] == state) {
            cells += 1;
        }

        return cells;
    }

    //riempie BC prendendo le celle libere adiacenti alle ultime 5 mosse;
    private ArrayList<MNKCell> findFreeCells(MNKBoard B, MNKCellState state) {

        ArrayList<MNKCell> BC = new ArrayList<MNKCell>();
        MNKCell MC[] = B.getMarkedCells();
        final int depth_MC = 10;

        for(int i=0; i < ((MC.length < depth_MC) ? MC.length : depth_MC); i++) {    

            MNKCell c = MC[MC.length-i-1];
            int m = c.i; int n = c.j;

            if(m-1 >= 0 && n-1 >= 0 && B.cellState(m-1, n-1) == MNKCellState.FREE) {
                if(isntAlready(BC, m-1, n-1)){
                    MNKCell d = new MNKCell(m-1, n-1);
                    BC.add(d);
                }
            }
            if(n-1 >= 0 && B.cellState(m, n-1) == MNKCellState.FREE) {
                if(isntAlready(BC, m, n-1)){
                    MNKCell d = new MNKCell(m, n-1);
                    BC.add(d);
                }
            }
            if(m+1 < M && n-1 >= 0 && B.cellState(m+1, n-1) == MNKCellState.FREE) {
                if(isntAlready(BC, m+1, n-1)){
                    MNKCell d = new MNKCell(m+1, n-1);
                    BC.add(d);
                }
            }
            if(m+1 < M && B.cellState(m+1, n) == MNKCellState.FREE) {
                if(isntAlready(BC, m+1, n)){
                    MNKCell d = new MNKCell(m+1, n);
                    BC.add(d);
                }
            }
            if(m+1 < M && n+1 < N && B.cellState(m+1, n+1) == MNKCellState.FREE) {
                if(isntAlready(BC, m+1, n+1)){
                    MNKCell d = new MNKCell(m+1, n+1);
                    BC.add(d);
                }
            }
            if(n+1 < N && B.cellState(m, n+1) == MNKCellState.FREE) {
                if(isntAlready(BC, m, n+1)){
                    MNKCell d = new MNKCell(m, n+1);
                    BC.add(d);
                }
            }
            if(m-1 >= 0 && n+1 < N && B.cellState(m-1, n+1) == MNKCellState.FREE) {
                if(isntAlready(BC, m-1, n+1)){
                    MNKCell d = new MNKCell(m-1, n+1);
                    BC.add(d);
                }
            }
            if( m-1 >= 0 && B.cellState(m-1, n) == MNKCellState.FREE) {
                if(isntAlready(BC, m-1, n)){
                    MNKCell d = new MNKCell(m-1, n);
                    BC.add(d);
                }
            }
        }

        return BC;
    }

    //riempie BC prendendo le celle libere con celle occupate adiacenti;
    private ArrayList<MNKCell> findFreeCells1(MNKBoard B, MNKCellState state) {

        ArrayList<MNKCell> BC = new ArrayList<MNKCell>();
        MNKCell FC[] = B.getFreeCells(); 
        MNKCell MC[] = B.getMarkedCells(); 
      
        for(MNKCell d : FC) {
            if(hasMarkedCellCloseBy(MC, d)) {
                if(isntAlready(BC, d.i, d.j)){
                    BC.add(d);
                }
            }
        } 

        return BC;
    }

    //verifica che una cella di coordinate m, n non sia già presente nell'array
    private boolean isntAlready(ArrayList<MNKCell> A, int m, int n) {
        for(int i=0; i < A.size(); i++) {
            if(A.get(i).i == m && A.get(i).j == n) return false;
        }
        return true;
    }

    private boolean hasMarkedCellCloseBy(MNKCell MC[], MNKCell c) {

        if(c.i+1 < M && c.j+1 < N) {
            for(MNKCell d : MC) {
                if(d.i == c.i+1 && d.j == c.j+1) return true;
            }
        }
        if(c.i+1 < M) {
            for(MNKCell d : MC) {
                if(d.i == c.i+1 && d.j == c.j) return true;
            }
        }
        if(c.i+1 < M && c.j-1 > 0) {
            for(MNKCell d : MC) {
                if(d.i == c.i+1 && d.j == c.j-1) return true;
            }
        }
        if(c.j-1 > 0) {
            for(MNKCell d : MC) {
                if(d.i == c.i && d.j == c.j-1) return true;
            }
        }
        if(c.i-1 > 0 && c.j-1 > 0) {
            for(MNKCell d : MC) {
                if(d.i == c.i-1 && d.j == c.j-1) return true;
            }
        }
        if(c.i-1 > 0) {
            for(MNKCell d : MC) {
                if(d.i == c.i-1 && d.j == c.j) return true;
            }
        }
        if(c.i-1 > 0 && c.j+1 < M) {
            for(MNKCell d : MC) {
                if(d.i == c.i-1 && d.j == c.j+1) return true;
            }
        }
        if(c.j+1 < M) {
            for(MNKCell d : MC) {
                if(d.i == c.i && d.j == c.j+1) return true;
            }
        }

		return false;	
    }
    
}
