private double evaluate(MNKCellState[][] B, MNKCellState state) {
        double u_max = 0.0;
        double u = 0.0;
        double m1=0.75;
        double m2=0.75;
        
        //controllo delle colonne
        for(int k=0; k < N; k++) {
            for(int h=0; h < M; h++) {
            	if (h==0) { //sto iniziando a contare o non ho ancora cominciato
            		m1=0.75;
            	}
            	else {
            		if(u==0 && B[h-1][k] == MNKCellState.FREE) {
            			m1=1;
            		}
            		else if(u==0){
            			m1=0.75;
            		}
            	}
            	if (h==M-1) { //sto finendo di contare o non ho ancora finito
            		m2=0.75;
            	}
            	else {
            		if(u!=0 && B[h+1][k] == MNKCellState.FREE) {
                		m2=1;
            		}
            		else if(u!=0) {
            			m2=0.75;
            		}
            	}
                if(B[h][k] == state) {
                    u++;
                    u_max = Math.max(u*m1*m2, u_max);
                }
                else {
                    u = 0.0;
                }
            }
            u = 0.0;
        }

        //controllo delle righe
        for(int k=0; k < M; k++) {
            for(int h=0; h < N; h++) {
            	
            	if (h==0) { //sto iniziando a contare o non ho ancora cominciato
            		m1=0.75;
            	}
            	else {
            		if(u==0 && B[k][h-1] == MNKCellState.FREE) {
            			m1=1;
            		}
            		else if(u==0) {
            			m1=0.75;
            		}
            	}
            	if (h==N-1) { //sto finendo di contare o non ho ancora finito
            		m2=0.75;
            	}
            	else {
            		if(u!=0 && B[k][h+1] == MNKCellState.FREE) {
                		m2=1;
            		}
            		else if(u!=0){
            			m2=0.75;
            		}
            	}
            	
                if(B[k][h] == state) {
                    u++;
                    u_max = Math.max(u*m1*m2, u_max);
                    }
                else {
                    u = 0;
                }
            }
            u = 0;
        }
            
        //CONTROLLO DIAGONALE 
        for (int j = 0; j<N; j++) { // MATRICE TRIANGOLARE SUPERIORE
        	int l = 0;
        	while (l<M && j+l<N) {
        		if (l==0) { //sto iniziando a contare o non ho ancora cominciato
        			u = 0;
        			m1=0.75;
        		}
        		else {
        			if(u==0 && B[l-1][j+l-1] == MNKCellState.FREE) {
                		m1=1;
            		}
        			else if(u==0) {
        				m1=0.75;
        			}
        		}
        		if (l==M-1|| j+l==N-1) { //sto finendo di contare o non ho ancora finito
        			m2=0.75;
        		}
        		else {
        			if(u!=0 && B[l+1][j+l+1] == MNKCellState.FREE) { 
        				m2=1;
        			}
        			else if(u!=0){
        				m2=0.75;
        			}
        		}
        		if (B[l][j+l] == state) {
        			u++;
        			u_max = Math.max(u*m1*m2, u_max);
        		}
        		else {
        			u=0;
        		}
        		l++;
        	}
        }
        for (int i = 1; i<M; i++) { // MATRICE TRIANGOLARE INFERIORE
        	int l=0;
        	while (l<N && i+l<M) { //sto iniziando a contare o non ho ancora cominciato
        		if (l==0) {
        			u=0;
        			m1=0.75;
        		}
        		else {
        			if(u==0 && B[i+l-1][l-1] == MNKCellState.FREE) {
                		m1=1;
            		}
        			else if(u==0) {
        				m1=0.75;
        			}
        			
        		}
        		if (i+l==M-1||l==N-1) { //sto finendo di contare o non ho ancora finito
        			m2=0.75;
        		}
        		else {
        			if(u!=0 && B[i+l+1][l+1] == MNKCellState.FREE) {
        				m2=1;
        			}
        			else if(u!=0){
        				m2=0.75;
        			}
        		}
        		if (B[i+l][l] == state) {
        			u++;
        			u_max = Math.max(u*m1*m2, u_max);
        		}
        		else {
        			u=0;
        		}
        		l++;
        	}
        }
        
        // CONTROLLO ANTI-DIAGONALE
        for (int j = N; j>0; j--) { // MATRICE TRIANGOLARE SUPERIORE (ANTI)
        	int l = 0;
        	while (l<M && j-l>0) {
        		if (l==0) { //sto iniziando a contare o non ho ancora cominciato
        			u=0;
        			m1=0.75;
        		}
        		else {
        			if(u==0 && B[l-1][j-l] == MNKCellState.FREE) {
        				m1=1;
        			}
        			else if(u==0) {
        				m1=0.75;
        			}
        		}
        		if (l==M-1 || j-l==1) { //sto finendo di contare o non ho ancora finito
        			m2=0.75;
        		}
        		else {
        			if(u!=0 && B[l+1][j-l] == MNKCellState.FREE) {
        				m2=1;
        			}
        			else if (u!=0) {
        				m2=0.75;
        			}
        		}
        		
        		
        		if (B[l][j-l-1] == state) {
        			u++;
        			u_max = Math.max(u*m1*m2, u_max);
        		}
        		else {
        			u=0;
        		}
        		l++;
        	}
        }
        for (int i = 1; i<M; i++) { // MATRICE TRIANGOLARE INFERIORE (ANTI)
        	int l = 0;
        	while (l+i<M && N-l>0) {
        		if (l==0) { //sto iniziando a contare o non ho ancora cominciato
        			u = 0;
        			m1=0.75;
        		}
        		else {
        			if(u==0 && B[i+l-1][N-l]== MNKCellState.FREE) {
        				m1=1;
        			}
        			else if(u==0) {
        				m1=0.75;
        			}
        		}
        		if (l+i==M-1 || N-l==1) { //sto finendo di contare o non ho ancora finito
        			m2=0.75;
        		}
        		else {
        			if(u!=0 && B[i+l+1][N-l] == MNKCellState.FREE) {
        				m2=1;
        			}
        			else if (u!=0) {
        				m2=0.75;
        			}
        		}
        		
        		if (B[i+l][N-l-1] == state) {
        			u++;
        			u_max = Math.max(u*m1*m2, u_max);
        		}
        		else {
        			u=0;
        		}
        		l++;
        	}
        }
        

        return u_max;
    }
